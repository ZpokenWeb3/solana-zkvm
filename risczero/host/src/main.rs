mod utils;


use crate::utils::{encode_seal, parse_transactions_info, TEST_BLOCK_HASH};
use clap::{App, Arg};
use futures::future;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{CUSTOM_METHOD_ELF, CUSTOM_METHOD_ID};
use risc0_zkvm::sha::Digestible;
use risc0_zkvm::{default_prover, ExecutorEnv, ProverOpts, VerifierContext};
use solana_sdk::hash::Hash;
use solana_sdk::transaction::VersionedTransaction;
use solana_simulator_types::result::SimulateSolanaRequest;
use std::io::Write;
use std::str::FromStr;
use svm_core::rpc::Rpc;
use svm_core::{rpc, simulate_solana};

#[tokio::main]
async fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let options = App::new("simulate Solana")
        .arg(
            Arg::with_name("config_file")
                .long("config_file")
                .takes_value(true)
                .help("Path to the Solana CLI configuration file"),
        )
        .arg(
            Arg::with_name("commitment")
                .long("commitment")
                .takes_value(true)
                .help("Commitment level (e.g., 'confirmed', 'processed')"),
        )
        .arg(
            Arg::with_name("json_rpc_url")
                .long("json_rpc_url")
                .takes_value(true)
                .help("URL of the Solana JSON RPC endpoint"),
        )
        .arg(
            Arg::with_name("keypair")
                .long("keypair")
                .takes_value(true)
                .help("Path to the keypair file"),
        )
        .arg(
            Arg::with_name("fee_payer")
                .long("fee_payer")
                .takes_value(true)
                .help("Path to the fee payer's keypair file"),
        )
        .arg(
            Arg::with_name("solana_key_for_config")
                .long("solana_key_for_config")
                .takes_value(true)
                .help("Public key for Solana config"),
        )
        .arg(
            Arg::with_name("transactions_file")
                .long("transactions_file")
                .takes_value(true)
                .help("Path to the Transactions file"),
        )
        .arg(
        Arg::with_name("block_hash")
            .long("block_hash")
            .takes_value(true)
            .help("Block hash"),
        )
        .get_matches();
    let config = &rpc::config::create(&options).unwrap();
    let rpc = rpc::config::build_rpc(config).await.unwrap();
    let transactions_info = parse_transactions_info(&options, config).unwrap();
    let futures: Vec<_> = transactions_info
        .iter()
        .map(|signature| rpc.get_transaction(signature))
        .collect();
    let results = future::join_all(futures).await;
    let transactions: Vec<VersionedTransaction> = results
        .into_iter()
        .filter_map(|result| {
            match result {
                Ok(Some(tx)) => Some(tx),
                _ => {
                    panic!("Transaction not found")
                }
            }
        })
        .collect();

    let block_hash = options.value_of("block_hash")
        .map_or_else(
            || Hash::from_str(TEST_BLOCK_HASH).unwrap(),
            |s| Hash::from_str(s).unwrap()
        );

    let request = SimulateSolanaRequest {
        compute_units: None,
        heap_size: None,
        account_limit: None,
        verify: Some(true),
        blockhash: block_hash.to_bytes(),
        transactions,
        id: None,
    };

    let solana_simulator = simulate_solana::init_simulator(&rpc, request.clone())
        .await
        .unwrap();

    let env = ExecutorEnv::builder()
        .write(&request)
        .unwrap()
        .write(&solana_simulator)
        .unwrap()
        .build()
        .unwrap();

    let receipt = default_prover()
        .prove_with_ctx(
            env,
            &VerifierContext::default(),
            CUSTOM_METHOD_ELF,
            &ProverOpts::groth16(),
        )
        .unwrap()
        .receipt;

    let journal = receipt.journal.bytes.clone();

    println!(
        "Encoded seal: {:?}",
        hex::encode(encode_seal(&receipt).unwrap())
    );
    println!("Journal: {:?}", hex::encode(journal));

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(CUSTOM_METHOD_ID).unwrap();
}
