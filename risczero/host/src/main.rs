use anyhow::bail;
use clap::{App, Arg};
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{CUSTOM_METHOD_ELF, CUSTOM_METHOD_ID};
use risc0_zkvm::sha::Digestible;
use risc0_zkvm::{default_prover, ExecutorEnv, InnerReceipt, ProverOpts, VerifierContext};
use solana_sdk::hash::Hash;
use solana_sdk::signature::Signature;
use solana_sdk::transaction::VersionedTransaction;
use solana_simulator_types::result::SimulateSolanaRequest;
use std::io::Write;
use std::str::FromStr;
use svm_core::rpc::Rpc;
use svm_core::{rpc, simulate_solana};

//WORKING TX
//3GmCvNvHkMRHUUAL9fYGFJuLkmaHZyXBvqKoBpWTnsYUfjhUS8JJKNFp2BejYY451btzAi2zS2v6uR9mYPdEtJe2
//2nXSpYaGqmxHgc8sQzm8oHBEBe6eWz6DLTPjoqbtrEtc
//
//5Q5ZCHZu2zJhngwpJXYucJpDvhGbYjLYncLV3KZt2R75jwPSZqFKmxq9K3WyDYqtMLugrVPXWieMvQgEq6XmzkL7
//HuKexVov6nz7F4veDEanw4FNYbFzyA67U6Phhrvbi4v2

pub fn encode_seal(receipt: &risc0_zkvm::Receipt) -> anyhow::Result<Vec<u8>> {
    let seal = match receipt.inner.clone() {
        InnerReceipt::Fake(receipt) => {
            let seal = receipt.claim.digest().as_bytes().to_vec();
            let selector = &[0u8; 4];
            let mut selector_seal = Vec::with_capacity(selector.len() + seal.len());
            selector_seal.extend_from_slice(selector);
            selector_seal.extend_from_slice(&seal);
            selector_seal
        }
        InnerReceipt::Groth16(receipt) => {
            let selector = &receipt.verifier_parameters.as_bytes()[..4];
            let mut selector_seal = Vec::with_capacity(selector.len() + receipt.seal.len());
            selector_seal.extend_from_slice(selector);
            selector_seal.extend_from_slice(receipt.seal.as_ref());
            selector_seal
        }
        _ => bail!("Unsupported receipt type"),
    };
    anyhow::Ok(seal)
}

#[tokio::main]
async fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let options = App::new("simulate Solana")
        .arg(
            Arg::with_name("config_file")
                .long("config_file")
                .takes_value(true)
                .help("Path to the Solana CLI configuration file"),
        )
        .arg(
            Arg::with_name("commitment")
                .long("commitment")
                .takes_value(true)
                .help("Commitment level (e.g., 'confirmed', 'processed')"),
        )
        .arg(
            Arg::with_name("json_rpc_url")
                .long("json_rpc_url")
                .takes_value(true)
                .help("URL of the Solana JSON RPC endpoint"), // .default_value("http://localhost:8899"))
        )
        .arg(
            Arg::with_name("keypair")
                .long("keypair")
                .takes_value(true)
                .help("Path to the keypair file"),
        )
        .arg(
            Arg::with_name("fee_payer")
                .long("fee_payer")
                .takes_value(true)
                .help("Path to the fee payer's keypair file"),
        )
        .arg(
            Arg::with_name("solana_key_for_config")
                .long("solana_key_for_config")
                .takes_value(true)
                .help("Public key for Solana config"),
        )
        .get_matches();
    let config = &rpc::config::create(&options).unwrap();
    let rpc = rpc::config::build_rpc(config).await.unwrap();
    let signature = Signature::from_str(
        "5Q5ZCHZu2zJhngwpJXYucJpDvhGbYjLYncLV3KZt2R75jwPSZqFKmxq9K3WyDYqtMLugrVPXWieMvQgEq6XmzkL7",
    )
    .unwrap();
    let transaction = rpc.get_transaction(&signature).await.unwrap().unwrap();

    let mut transactions: Vec<VersionedTransaction> = vec![];
    transactions.push(transaction);

    let request = SimulateSolanaRequest {
        compute_units: None,
        heap_size: None,
        account_limit: None,
        verify: Some(true),
        blockhash: Hash::from_str("HuKexVov6nz7F4veDEanw4FNYbFzyA67U6Phhrvbi4v2")
            .unwrap()
            .to_bytes(),
        transactions,
        id: None,
    };
    let solana_simulator = simulate_solana::init_simulator(&rpc, request.clone())
        .await
        .unwrap();

    let env = ExecutorEnv::builder()
        .write(&request)
        .unwrap()
        .write(&solana_simulator)
        .unwrap()
        .build()
        .unwrap();

    let receipt = default_prover()
        .prove_with_ctx(
            env,
            &VerifierContext::default(),
            CUSTOM_METHOD_ELF,
            &ProverOpts::groth16(),
        )
        .unwrap()
        .receipt;

    let journal = receipt.journal.bytes.clone();

    println!(
        "Encoded seal: {:?}",
        hex::encode(encode_seal(&receipt).unwrap())
    );
    println!("Journal: {:?}", hex::encode(journal));

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(CUSTOM_METHOD_ID).unwrap();
}
